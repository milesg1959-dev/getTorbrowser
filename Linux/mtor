#!/usr/bin/env bash

# File        :  mtor
#
# Purpose     :  A Multiple Tor(onion routers) launch/terminate/... script
#
# Copyright   :  Written by and Copyright (C) 2023-03-15
#                Miles Guo. komg@hotmail.com
#
#                This program is free software; you can redistribute it
#                and/or modify it under the terms of the GNU General
#                Public License as published by the Free Software
#                Foundation; either version 2 of the License, or (at
#                your option) any later version.
#
#                This program is distributed in the hope that it will
#                be useful, but WITHOUT ANY WARRANTY; without even the
#                implied warranty of MERCHANTABILITY or FITNESS FOR A
#                PARTICULAR PURPOSE.  See the GNU General Public
#                License for more details.
#
#                The GNU General Public License should be included with
#                this file.  If not, you can view it at
#                http://www.gnu.org/copyleft/gpl.html
#                or write to the Free Software Foundation, Inc.,
#                51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
#                USA
#
# Modification : If you modify this file please consider whether your 
#                changes ought to be passed back to me.
#

## From Tor control protocol (Version 1)

## SIGNAL

#  Sent from the client to the server. The syntax is:

#  "SIGNAL" SP Signal CRLF

#  Signal = "RELOAD" / "SHUTDOWN" / "DUMP" / "DEBUG" / "HALT" /
#           "HUP" / "INT" / "USR1" / "USR2" / "TERM" / "NEWNYM" /
#           "CLEARDNSCACHE" / "HEARTBEAT" / "ACTIVE" / "DORMANT"
#
#  The meaning of the signals are:

#      RELOAD    -- Reload: reload config items.
#      SHUTDOWN  -- Controlled shutdown: if server is an OP, exit immediately.
#                   If it's an OR, close listeners and exit after
#                   ShutdownWaitLength seconds.
#      DUMP      -- Dump stats: log information about open connections and
#                   circuits.
#      DEBUG     -- Debug: switch all open logs to loglevel debug.
#      HALT      -- Immediate shutdown: clean up and exit now.
#      CLEARDNSCACHE -- Forget the client-side cached IPs for all hostnames.
#      NEWNYM    -- Switch to clean circuits, so new application requests
#                   don't share any circuits with old ones.  Also clears
#                   the client-side DNS cache.  (Tor MAY rate-limit its
#                   response to this signal.)
#      HEARTBEAT -- Make Tor dump an unscheduled Heartbeat message to log.
#      DORMANT   -- Tell Tor to become "dormant".  A dormant Tor will
#                   try to avoid CPU and network usage until it receives
#                   user-initiated network request.  (Don't use this
#                   on relays or hidden services yet!)
#      ACTIVE    -- Tell Tor to stop being "dormant", as if it had received
#                   a user-initiated network request.

#  The server responds with "250 OK" if the signal is recognized (or simply
#  closes the socket if it was asked to close immediately), or "552
#  Unrecognized signal" if the signal is unrecognized.

#  Note that not all of these signals have POSIX signal equivalents.  The
#  ones that do are as below.  You may also use these POSIX names for the
#  signal that have them.

#      RELOAD: HUP
#      SHUTDOWN: INT
#      HALT: TERM
#      DUMP: USR1
#      DEBUG: USR2

#  [SIGNAL DORMANT and SIGNAL ACTIVE were added in 0.4.0.1-alpha.]

cd "$(dirname "$0")"

usage() {
  cat <<EOF
Usage: $0 {instance} {start|stop|reload|cleardnscache|newnym|dormant|active}
  Instence: 1..n

The meaning of the signals are:
  start         -- Start Tor service.
  stop          -- Shutdown Tor service.
  reload        -- Reload config items.
  cleardnscache -- Forget the client-side cached IPs for all hostnames.
  newnym        -- Switch to clean circuits, so new application requests
                   don't share any circuits with old ones.  Also clears
                   the client-side DNS cache.  (Tor MAY rate-limit its
                   response to this signal.)
  dormant       -- Tell Tor to become "dormant".  A dormant Tor will
                   try to avoid CPU and network usage until it receives
                   user-initiated network request.  (Don't use this
                   on relays or hidden services yet!)
  active        -- Tell Tor to stop being "dormant", as if it had received
                   a user-initiated network request.
EOF
  exit 1
}

[ $# -ne 2 ] && usage

TOR_INSTANCES="$1"
#TOR_SIGNAL="$2"

# check nc
NCPATH=/usr/bin
NCBIN=$NCPATH/nc
if [ ! -x $NCBIN ]; then
  echo "Sorry, I can't find nc, that is used to communicate with Tor process."
  echo "The control signals needs to be send via nc/netcat."
  echo "Please refer to the readme.md for the solution."
  exit 1
fi

# check tor
TEBPATH=$PWD/tor-expert-bundle
TORPATH=$TEBPATH/tor
TORBIN=$TORPATH/tor
if [ ! -x $TORBIN ]; then
  echo "Sorry, I can't find tor."
  echo "Please refer to the readme.md to download and install the Tor Expert Bundle first."
  exit 1
fi

TOR_TORRC=$PWD/torrc
[ -f $TOR_TORRC ] || exit 1
TOR_GEOIP=$TEBPATH/data/geoip
TOR_GEOIP6=$TEBPATH/data/geoip6

TOR_HOST="127.0.0.1"
TOR_BASE_SOCKS_PORT=9050
TOR_BASE_CTRL_PORT=19050
TOR_HASHPASS="16:95808DE6B3C05297608CEFB43053E55F2755284AAA43650AF441A74DFD"
TOR_PASS="toralone"

RUNPATH=$PWD/run

RETVAL=0
mRETVAL=0

start() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    LOGFILE=$RUNPATH/tor$i/tor$i.log
    if [ -e $PIDFILE ]; then
      echo "tor$i is already running."
      mRETVAL=0
      echo
    else
      data_dir=$RUNPATH/tor$i
      if [ ! -d "$data_dir" ]; then
        echo "Creating directory $data_dir"
        mkdir -p -m 700 "$data_dir"
      fi
      socks_port=$((TOR_BASE_SOCKS_PORT+$i))
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      echo "Starting tor$i"
      OLDPATH=$PWD
      cd $TORPATH
      $TORBIN --PidFile $PIDFILE -f $TOR_TORRC --DataDirectory $data_dir --GeoIPFile $TOR_GEOIP --GeoIPv6File $TOR_GEOIP6 --HashedControlPassword $TOR_HASHPASS --NewCircuitPeriod 60 --ControlPort $control_port --SocksPort "$TOR_HOST:$socks_port IPv6Traffic PreferIPv6 KeepAliveIsolateSOCKSAuth" >$LOGFILE 2>&1 &
      mRETVAL=$?
      echo
      cd $OLDPATH
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

stop() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    LOGFILE=$RUNPATH/tor$i/tor$i.log
    if [ -e $PIDFILE ]; then
      echo "Shutting down tor$i"
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL SHUTDOWN
QUIT
EOF
      mRETVAL=$?
      echo
      [ $mRETVAL -eq 0 ] && rm -f $PIDFILE
      [ $mRETVAL -eq 0 ] && rm -f $LOGFILE
    else
      echo "tor$i is not running."
      mRETVAL=0
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

reload() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    if [ -e $PIDFILE ]; then
      echo "tor$i: reload config items."
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL RELOAD
QUIT
EOF
      mRETVAL=$?
      echo
    else
      echo "tor$i is not running."
      mRETVAL=1
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

cleardnscache() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    if [ -e $PIDFILE ]; then
      echo "tor$i: Forget the client-side cached IPs for all hostnames."
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL CLEARDNSCACHE
QUIT
EOF
      mRETVAL=$?
      echo
    else
      echo "tor$i is not running."
      mRETVAL=1
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

newnym() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    if [ -e $PIDFILE ]; then
      echo "tor$i: Switch to clean circuits."
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL NEWNYM
QUIT
EOF
      mRETVAL=$?
      echo
      sleep 10
    else
      echo "tor$i is not running."
      mRETVAL=1
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

dormant() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    if [ -e $PIDFILE ]; then
      echo "tor$i: To become dormant."
      control_port=$((TOR_BASE_CTRL_PORT+$i))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL DORMANT
QUIT
EOF
      mRETVAL=$?
      echo
    else
      echo "tor$i is not running."
      mRETVAL=1
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

active() {
  num=`expr $TOR_INSTANCES - 0`
  for i in $(seq 1 $num)
  do
    PIDFILE=$RUNPATH/tor$i/tor$i.pid
    if [ -e $PIDFILE ]; then
      echo "tor$i: To stop being dormant."
      control_port=$((TOR_BASE_CTRL_PORT+$1))
      $NCBIN $TOR_HOST $control_port << EOF
AUTHENTICATE "$TOR_PASS"
SIGNAL ACTIVE
QUIT
EOF
      mRETVAL=$?
      echo
    else
      echo "tor$i is not running."
      mRETVAL=1
      echo
    fi
    RETVAL=`expr $RETVAL + $mRETVAL`
    i=`expr $i + 1`
  done
  return $RETVAL
}

##
# Generic action handler
##
case "$2" in 
  start         ) start;;
  reload        ) reload;;
  stop          ) stop;;
  cleardnscache ) cleardnscache;;
  newnym        ) newnym;;
  dormant       ) dormant;;
  active        ) active;;
  *             ) usage;;
esac

exit $?

## End of mtor